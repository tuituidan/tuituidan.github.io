{"meta":{"title":"朱军函个人博客","subtitle":"技术分享","description":"description","author":"朱军函","url":"https://zhujunhan.github.io","root":"/"},"pages":[{"title":"","date":"2019-05-07T11:45:56.153Z","updated":"2019-04-20T14:21:57.033Z","comments":true,"path":"README.html","permalink":"https://zhujunhan.github.io/README.html","excerpt":"","text":"zhujunhan.github.io 这是我的 个人博客 仓库。"},{"title":"个人简介","date":"2019-04-17T16:00:00.000Z","updated":"2019-05-07T14:00:21.848Z","comments":true,"path":"about/index.html","permalink":"https://zhujunhan.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 JAVA、C#。 比起掉发，我更怕掉队 联系我 Blog: zhujunhan.github.io Email: 136375002@qq.com GitHub: zhujunhan"}],"posts":[{"title":"基于百度webuploader封装的上传控件","slug":"webuploader","date":"2018-06-17T16:00:00.000Z","updated":"2019-05-08T04:02:57.574Z","comments":true,"path":"2018/06/18/webuploader/","link":"","permalink":"https://zhujunhan.github.io/2018/06/18/webuploader/","excerpt":"","text":"基于百度webuploader封装的一个上传控件，解决了IE下使用flash上传一些问题，简化了调用过程。 使用方式： 页面引入css文件webuploader.css，js文件jquery.min.js、webuploader.js、uploader.js 在需要生成上传控件的地方添加html代码：&lt;div id=&quot;uploader&quot; class=&quot;uploader&quot;&gt;&lt;/div&gt; 生成控件js代码：var upload = $(&quot;#uploader&quot;).createUploader(params);或或new UploadFile(&quot;upload&quot;,params) params为json对象，设置上传控件初始化参数，参数如下（均有默认值，可选填） extraData ： 额外传到服务器的参数，默认{}，示例：{xxx:123,bbb:’ddg’}fileList：初始添加的文件，默认[]，示例：[{name:’name’,ext:’doc’,prevurl:’prevurl’,filepath:’filepath’},{…}]maxCount：可添加的上传文件个数，默认9submitName：提交值的name属性值，默认”fileName”serverUrl：文件上传的服务地址，默认”/api/v1/upload”acceptExt：允许上传的文件格式，示例”jpg,jpeg,gif,png,bmp” 支持格式包括：png,jpg,jpeg,gif,bmp,flv,swf,mkv,avi,rm,rmvb,mpeg,mpg,ogg,ogv,mov,wmv,mp4,webm,mp3,wav,mid,rar,zip,tar,gz,7z,bz2,cab,iso,doc,docx,xls,xlsx,ppt,pptx,pdf,txt,md,xml autoload：选择文件后是否自动上传，默认false, true表示添加文件后自动上传，上传后得到的文件路径为上面设置的name为submitName的值的input标签的值。 false表示不自动上传，则需要添加上传按钮进行上传，调用下面的代码可获得上传文件路径 1234&gt; &gt; upload.uploadFile(function(vals) &#123;&gt; &gt; console.log(vals);&gt; &gt; &#125;); &gt; &gt; promptText：显示在上传控件的下面的一行字，作为提示，提高用户体验，示例”提示：最多可同时上传3个文件，每个文件不超过100M。” 封装说明 支持设置初始值，如编辑商品的时候，商品图片已经上传了一些，就需要以新增时一样的方式显示出来。 根据传入的支持的文件格式自动生成accept属性，可在选择文件框中自动过滤掉不支持的格式。 自动检测Uploader.swf的路径。 因为Uploader.swf传入的路径必须是相对于当前html页面的路径，但项目中各个上传页面路径都不一样，所以无法设置统一的值。 解决使用flash上传时，添加文件达到最大支持个数，隐藏上传按钮后，再移除文件后上传按钮不显示的问题。 使用flash上传时，上传按钮不能用jq的hide方法（即css的display:none）来隐藏，需要用样式 123456&gt; .webuploader-element-invisible &#123;&gt; position: absolute !important;&gt; clip: rect(1px 1px 1px 1px); &gt; clip: rect(1px,1px,1px,1px);&gt; &#125;&gt; 来控制 添加ocx解决IE下flash被禁用的问题。 在IE低版本使用flash上传时，如果flash安装了只是被禁用了，webuploader源码中的方法也会检测为没安装（实际也是js是无法检测windows组件是否安装的），所以添加Flash11e.ocx来强行提示用户开启 下调flash支持版本为11.1 源码中要求的flash版本至少为11.4，实际生产环境客户正好用的11.1，下调为11.1测试后发现仍然正常 封装源码移步GitHub","categories":[{"name":"前端","slug":"前端","permalink":"https://zhujunhan.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zhujunhan.github.io/tags/前端/"},{"name":"webuploader","slug":"webuploader","permalink":"https://zhujunhan.github.io/tags/webuploader/"}],"author":"zhujunhan"},{"title":"Disruptor","slug":"Disruptor","date":"2017-06-17T16:00:00.000Z","updated":"2019-05-08T01:21:57.064Z","comments":true,"path":"2017/06/18/Disruptor/","link":"","permalink":"https://zhujunhan.github.io/2017/06/18/Disruptor/","excerpt":"","text":"DisruptorDisruptor是什么（http://ifeve.com/disruptor） 1：Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级） 2：Disruptor实现对了队列的功能并且是一个有界队列。可以用于生产者-消费者模型。 juc下的队列 队列 有界性 锁 数据结构 ArrayBlockingQueue bounded 加锁 arraylist LinkedBlockingQueue optionally-bounded 加锁 linkedlist ConcurrentLinkedQueue unbounded 无锁 linkedlist LinkedTransferQueue unbounded 无锁 linkedlist PriorityBlockingQueue unbounded 加锁 heap DelayQueue unbounded 加锁 heap 1：从上图可以看出，juc下的队列基本采用加锁方式保证线程安全。通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在限定的范围）。而加锁的方式可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。 2：加锁的方式通常严重影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。 3：有界队列通常采用数组实现。但是采用数组实现又会引发另外一个问题false sharing(伪共享)。 Disruptor核心类 1：RingBuffer：Disruptor最主要的组件，仅仅负责存储和更新事件对象。 2：Sequence：Disruptor使用Sequence来表示一个特殊组件处理的序号。和Disruptor一样，每一个消费者（EventProcessor）都维持着一个Sequence。大部分的并发代码依赖这这个值。这个类维护了一个long类型的value，采用的unsafe进行的更新操作。 3：Sequencer：这是Disruptor真正的核心。实现了这个接口的两种生产者（单生产者和多生产者）均实现了所有的并发算法，为了在生产者和消费者之间进行准确快速的数据传递。 4：SequenceBarrier：由Sequencer生成，并且包含了已经发布的Sequence的引用，这些Sequence源于Sequencer和一些独立的消费者的Sequence。它包含了决定是否有供消费者消费的Event的逻辑。用来权衡当消费者无法从RingBuffer里面获取事件时的处理策略。（例如：当生产者太慢，消费者太快，会导致消费者获取不到新的事件会根据该策略进行处理，默认会堵塞） 5：WaitStrategy：决定一个消费者将如何等待生产者将Event置入Disruptor的策略。用来权衡当生产者无法将新的事件放进RingBuffer时的处理策略。（例如：当生产者太快，消费者太慢，会导致生产者获取不到新的事件槽来插入新事件，则会根据该策略进行处理，默认会堵塞） 6：Event：从生产者到消费者过程中所处理的数据单元。Disruptor中没有代码表示Event，因为它完全是由用户定义的。 7：EventProcessor：主要事件循环，处理Disruptor中的Event，并且拥有消费者的Sequence。它有一个实现类是BatchEventProcessor，包含了event loop有效的实现，并且将回调到一个EventHandler接口的实现对象。 8：EventHandler：由用户实现并且代表了Disruptor中的一个消费者的接口。 9：WorkHandler：在work模式下使用。由用户实现并且代表了Disruptor中的多个消费者的接口。 10：WorkProcessor：确保每个sequence只被一个processor消费，在同一个WorkPool中的处理多个WorkProcessor不会消费同样的sequence。 11：WorkerPool：一个WorkProcessor池，其中WorkProcessor将消费Sequence，所以任务可以在实现WorkHandler接口的worker之间移交 12：LifecycleAware：当BatchEventProcessor启动和停止时，实现这个接口用于接收通知。 Disruptor为什么这么快 1、不使用锁，通过内存屏障和原子性的CAS操作替换锁。 2、缓存基于数组而不是链表，用位运算替代求模%。缓存的长度总是2的n次方，这样可以用位运算i &amp; (length -1)替代i % length。 3、去除伪共享，CPU的缓存一般是以缓存行为最小单位的，对应主存的一块相应大小的单元，当前的缓存行大小一般是64字节，每个缓存行—次只能被一个CPU核访问，如果一个缓存行被多个CPU核访问，就会造成竞争，导致某个核必须等待其他核处理完了才能继续处理，影响性能。去除伪共享就是确保CPU核访问某个缓存行时不会出现争用。 4、预分配缓存对象，通过更新缓存里对象的属性而不是删除对象来减少垃圾回收。","categories":[{"name":"Disruptor","slug":"Disruptor","permalink":"https://zhujunhan.github.io/categories/Disruptor/"}],"tags":[{"name":"Disruptor","slug":"Disruptor","permalink":"https://zhujunhan.github.io/tags/Disruptor/"},{"name":"RingBuffer","slug":"RingBuffer","permalink":"https://zhujunhan.github.io/tags/RingBuffer/"}],"author":"zhujunhan"}]}