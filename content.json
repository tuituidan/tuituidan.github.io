{"meta":{"title":"朱军函个人博客","subtitle":"技术分享","description":"description","author":"朱军函","url":"https://zhujunhan.github.io","root":"/"},"pages":[{"title":"","date":"2019-05-07T11:45:56.153Z","updated":"2019-04-20T14:21:57.033Z","comments":true,"path":"README.html","permalink":"https://zhujunhan.github.io/README.html","excerpt":"","text":"zhujunhan.github.io 这是我的 个人博客 仓库。"},{"title":"about","date":"2019-05-07T10:07:59.000Z","updated":"2019-05-07T10:07:59.360Z","comments":true,"path":"about/index.html","permalink":"https://zhujunhan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"webuploader","date":"2019-04-20T13:03:48.674Z","updated":"2019-01-27T10:23:43.761Z","comments":true,"path":"2019/04/20/webuploader/","link":"","permalink":"https://zhujunhan.github.io/2019/04/20/webuploader/","excerpt":"","text":"webuploader使用方式：html代码：&lt;div id=&quot;uploader&quot; class=&quot;uploader&quot;&gt;&lt;/div&gt;生成控件代码：var upload = $(&quot;#uploader&quot;).createUploader();","categories":[],"tags":[]},{"title":"Disruptor","slug":"Disruptor","date":"2017-06-17T16:00:00.000Z","updated":"2019-05-07T12:58:57.414Z","comments":true,"path":"2017/06/18/Disruptor/","link":"","permalink":"https://zhujunhan.github.io/2017/06/18/Disruptor/","excerpt":"","text":"DisruptorDisruptor是什么（http://ifeve.com/disruptor） 1：Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级） 2：Disruptor实现对了队列的功能并且是一个有界队列。可以用于生产者-消费者模型。 juc下的队列 队列 有界性 锁 数据结构 ArrayBlockingQueue bounded 加锁 arraylist LinkedBlockingQueue optionally-bounded 加锁 linkedlist ConcurrentLinkedQueue unbounded 无锁 linkedlist LinkedTransferQueue unbounded 无锁 linkedlist PriorityBlockingQueue unbounded 加锁 heap DelayQueue unbounded 加锁 heap 1：从上图可以看出，juc下的队列基本采用加锁方式保证线程安全。通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在限定的范围）。而加锁的方式可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。 2：加锁的方式通常严重影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。 3：有界队列通常采用数组实现。但是采用数组实现又会引发另外一个问题false sharing(伪共享)。 Disruptor核心类 1：RingBuffer：Disruptor最主要的组件，仅仅负责存储和更新事件对象。 2：Sequence：Disruptor使用Sequence来表示一个特殊组件处理的序号。和Disruptor一样，每一个消费者（EventProcessor）都维持着一个Sequence。大部分的并发代码依赖这这个值。这个类维护了一个long类型的value，采用的unsafe进行的更新操作。 3：Sequencer：这是Disruptor真正的核心。实现了这个接口的两种生产者（单生产者和多生产者）均实现了所有的并发算法，为了在生产者和消费者之间进行准确快速的数据传递。 4：SequenceBarrier：由Sequencer生成，并且包含了已经发布的Sequence的引用，这些Sequence源于Sequencer和一些独立的消费者的Sequence。它包含了决定是否有供消费者消费的Event的逻辑。用来权衡当消费者无法从RingBuffer里面获取事件时的处理策略。（例如：当生产者太慢，消费者太快，会导致消费者获取不到新的事件会根据该策略进行处理，默认会堵塞） 5：WaitStrategy：决定一个消费者将如何等待生产者将Event置入Disruptor的策略。用来权衡当生产者无法将新的事件放进RingBuffer时的处理策略。（例如：当生产者太快，消费者太慢，会导致生产者获取不到新的事件槽来插入新事件，则会根据该策略进行处理，默认会堵塞） 6：Event：从生产者到消费者过程中所处理的数据单元。Disruptor中没有代码表示Event，因为它完全是由用户定义的。 7：EventProcessor：主要事件循环，处理Disruptor中的Event，并且拥有消费者的Sequence。它有一个实现类是BatchEventProcessor，包含了event loop有效的实现，并且将回调到一个EventHandler接口的实现对象。 8：EventHandler：由用户实现并且代表了Disruptor中的一个消费者的接口。 9：WorkHandler：在work模式下使用。由用户实现并且代表了Disruptor中的多个消费者的接口。 10：WorkProcessor：确保每个sequence只被一个processor消费，在同一个WorkPool中的处理多个WorkProcessor不会消费同样的sequence。 11：WorkerPool：一个WorkProcessor池，其中WorkProcessor将消费Sequence，所以任务可以在实现WorkHandler接口的worker之间移交 12：LifecycleAware：当BatchEventProcessor启动和停止时，实现这个接口用于接收通知。 Disruptor为什么这么快 1、不使用锁，通过内存屏障和原子性的CAS操作替换锁。 2、缓存基于数组而不是链表，用位运算替代求模%。缓存的长度总是2的n次方，这样可以用位运算i &amp; (length -1)替代i % length。 3、去除伪共享，CPU的缓存一般是以缓存行为最小单位的，对应主存的一块相应大小的单元，当前的缓存行大小一般是64字节，每个缓存行—次只能被一个CPU核访问，如果一个缓存行被多个CPU核访问，就会造成竞争，导致某个核必须等待其他核处理完了才能继续处理，影响性能。去除伪共享就是确保CPU核访问某个缓存行时不会出现争用。 4、预分配缓存对象，通过更新缓存里对象的属性而不是删除对象来减少垃圾回收。","categories":[{"name":"Disruptor","slug":"Disruptor","permalink":"https://zhujunhan.github.io/categories/Disruptor/"}],"tags":[{"name":"Disruptor","slug":"Disruptor","permalink":"https://zhujunhan.github.io/tags/Disruptor/"},{"name":"RingBuffer","slug":"RingBuffer","permalink":"https://zhujunhan.github.io/tags/RingBuffer/"}],"author":"zhujunhan"}]}